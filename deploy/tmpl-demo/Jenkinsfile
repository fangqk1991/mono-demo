#!groovy
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import java.util.regex.Matcher
import java.util.regex.Pattern

////////////////////// å…¬å…±ä»£ç  START //////////////////////
////////////////////// version: V1.2022-10-14: + Telegram Bot //////////////////////
////////////////////// version: V1.2023-03-02: + Feishu Bot //////////////////////

class MessagePusher {
  public static def jenkins
  public static String wechatBotKey
  public static String feishuBotKey

  public static String telegramBotToken
  public static String chatId

  public static def notify(String message) {
    this.notifyToTelegram(message)
    this.notifyToFeishu(message)
    this.notifyToWecom(message)
  }

  public static def notifyToFeishu(String message) {
    if (!this.feishuBotKey) {
      return
    }
    def data = JsonOutput.toJson([
      msg_type: 'text',
      content: [
        text:  message,
      ],
    ])
    jenkins.sh """
      curl https://open.feishu.cn/open-apis/bot/v2/hook/${this.feishuBotKey} \
      --silent --output /dev/null --request POST --header 'Content-Type: application/json' \
      --data '${data}'
    """
  }

  public static def notifyToWecom(String message) {
    if (!this.wechatBotKey) {
      return
    }
    def data = JsonOutput.toJson([
      msgtype: 'text',
      text: [
        content:  message,
      ],
    ])
    jenkins.sh """
      curl https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=${this.wechatBotKey} \
      --silent --output /dev/null --request POST --header 'Content-Type: application/json' \
      --data '${data}'
    """
  }

  public static def notifyToTelegram(String message) {
    if (!this.telegramBotToken || !this.chatId) {
      return
    }
    def data = JsonOutput.toJson([
      text: message,
    ])
    jenkins.sh """
      curl https://api.telegram.org/bot${this.telegramBotToken}/sendMessage?chat_id=${this.chatId} \
      --silent --output /dev/null --request POST --header 'Content-Type: application/json' \
      --data '${data}'
    """
  }
}
MessagePusher.jenkins = this

class RemoteHost {
  static def jenkins

  public String internalIPAddress
  public String name
  public String host
  public Integer port
  public String user

  def _execCommand(String command, Boolean ignoreError = false) {
    def remoteInfo = [:]
    remoteInfo.host = this.host
    remoteInfo.port = this.port
    remoteInfo.user = this.user
    remoteInfo.name = this.name
    remoteInfo.identityFile = jenkins.DEPLOY_ACCESS_KEY
    remoteInfo.allowAnyHosts = true
    // sshCommand: https://www.jenkins.io/doc/pipeline/steps/ssh-steps/
    // sshCommand: https://github.com/jenkinsci/ssh-steps-plugin
    def result = jenkins.sshCommand remote: remoteInfo, command: command, failOnError: !ignoreError
    return result
  }

  def execCommand(String command, Boolean ignoreError = false) {
    return this._execCommand(command, ignoreError)
  }

  def execCommandByForce(String command) {
    return this.execCommand(command, true)
  }

  def execCurl(String method, String url, Object bodyData = null) {
    def command = "curl --silent --fail --show-error --connect-timeout 3 -X ${method} \"${url}\""
    if (bodyData) {
      command = "${command} -H \"Content-type: application/json\" --data '${JsonOutput.toJson(bodyData)}'"
    }
    return this._execCommand(command)
  }

  def execCurl(CurlParams params) {
    return this._execCommand(params.build())
  }

  def publishLatestToBackupService(DockerApp dockerApp, RuntimeParams params) {
    this.fetchLatestImage(dockerApp)

    this.dropBackupService(dockerApp)

    // åˆ é™¤å½“å‰ dockerApp.imageNameBak() é•œåƒï¼Œå¹¶å°† dockerApp.latestImageTag é•œåƒå¤‡ä»½åˆ° dockerApp.imageNameBak()
    this.execCommandByForce("docker image rm ${dockerApp.imageNameBak()}")
    this.execCommand("docker tag ${dockerApp.latestImageTag} ${dockerApp.imageNameBak()}")

    def tagsParams = [
      Tags: ['Backup']
    ]
    def envConfigData = JsonOutput.toJson(tagsParams + params.envConfigData)
    def envConfigDataExtras = JsonOutput.toJson(tagsParams + params.envConfigDataExtras + dockerApp.getConfigDataExtras())
    def hostnameSuffix = params.hostnameSuffix ? "-${params.hostnameSuffix}" : ''

    def portMapperList = dockerApp.makePortMapperList()
    // å¯åŠ¨ Backup æœåŠ¡
    this.execCommandByForce("docker run -d --restart=unless-stopped \
        --hostname=\"${dockerApp.realName()}-`hostname`${hostnameSuffix}\" \
        --name=${dockerApp.containerNameBak()} \
        --memory=\"${params.memoryLimit}\" \
        -v '${dockerApp.logsDir()}:${dockerApp.logsDir()}' \
        -e 'ENV=${params.configEnv}' \
        -e 'configSecret=${params.configSecret}' \
        -e 'NODE_CONFIG_EXTRA_JS=${params.extraConfigPath}' \
        -e 'ENV_CONFIG_DATA=${envConfigData}' \
        -e 'ENV_CONFIG_DATA_EXTRAS=${envConfigDataExtras}' \
        ${dockerApp.bindVolumesStr()} \
        ${portMapperList.collect({ "-p ${it.hostPortBak}:${it.containerPort}" }).join(' ')} \
        ${dockerApp.imageNameBak()} \
    ")
  }

  def duplicateBackupService(DockerApp dockerApp, RuntimeParams params) {
    this.dropBackupService(dockerApp)

    // åˆ é™¤å½“å‰ dockerApp.imageNameBak() é•œåƒï¼Œå¹¶å°† dockerApp.imageName() é•œåƒå¤‡ä»½åˆ° dockerApp.imageNameBak()
    this.execCommandByForce("docker image rm ${dockerApp.imageNameBak()}")

    try {
      this.execCommand("docker tag ${dockerApp.imageName()} ${dockerApp.imageNameBak()}")
    } catch (Exception e) {
      def commitSHA = this.getLastContainerCommitSHA(dockerApp)
      this.notify("âš ï¸ [${dockerApp.appName}] ä¸Šæ¬¡å‘å¸ƒçš„ ${commitSHA} ä¸»é•œåƒä¸å­˜åœ¨")
      def lastImageTag = "${dockerApp.dockerImageRepo}:${commitSHA}"
      this.execCommand("docker pull ${lastImageTag}")
      this.execCommand("docker tag ${lastImageTag} ${dockerApp.imageName()}")
      this.execCommand("docker tag ${dockerApp.imageName()} ${dockerApp.imageNameBak()}")
      this.notify("âœ”ï¸ [${dockerApp.appName}] ${commitSHA} å·²é‡æ–°è·å–å¹¶äº§ç”Ÿå¤‡ç”¨é•œåƒ")
    }

    def tagsParams = [
      Tags: ['Backup']
    ]
    def envConfigData = JsonOutput.toJson(tagsParams + params.envConfigData)
    def envConfigDataExtras = JsonOutput.toJson(tagsParams + params.envConfigDataExtras + dockerApp.getConfigDataExtras())
    def hostnameSuffix = params.hostnameSuffix ? "-${params.hostnameSuffix}" : ''

    def portMapperList = dockerApp.makePortMapperList()
    // å¯åŠ¨ Backup æœåŠ¡
    this.execCommandByForce("docker run -d --restart=unless-stopped \
        --hostname=\"${dockerApp.realName()}-`hostname`${hostnameSuffix}\" \
        --name=${dockerApp.containerNameBak()} \
        --memory=\"${params.memoryLimit}\" \
        -v '${dockerApp.logsDir()}:${dockerApp.logsDir()}' \
        -e 'ENV=${params.configEnv}' \
        -e 'configSecret=${params.configSecret}' \
        -e 'NODE_CONFIG_EXTRA_JS=${params.extraConfigPath}' \
        -e 'ENV_CONFIG_DATA=${envConfigData}' \
        -e 'ENV_CONFIG_DATA_EXTRAS=${envConfigDataExtras}' \
        ${dockerApp.bindVolumesStr()} \
        ${portMapperList.collect({ "-p ${it.hostPortBak}:${it.containerPort}" }).join(' ')} \
        ${dockerApp.imageNameBak()} \
    ")
  }

  def checkMainDockerContainerExists(DockerApp dockerApp) {
    def retCode = this.execCommand("docker container inspect ${dockerApp.containerName()} > /dev/null; echo \$?")
    return retCode == '0'
  }

  def getLastContainerCommitSHA(DockerApp dockerApp) {
    def responseText = this.execCommand("docker container inspect ${dockerApp.containerName()}")
    def responseObj = new JsonSlurper().parseText(responseText)
    def commitSHA = responseObj[0]['Config']['Labels']['commitSHA']
    return commitSHA
  }

  def fetchLatestImage(DockerApp dockerApp) {
    assert dockerApp.latestImageTag != null
    this.execCommand("${jenkins.HUB_LOGIN}")
    this.execCommand("docker pull ${dockerApp.latestImageTag}")
  }

  def prepareMainDockerImage(DockerApp dockerApp) {
    this.fetchLatestImage(dockerApp)
    // åˆ é™¤å½“å‰ dockerApp.imageName() é•œåƒï¼Œå¹¶å°† dockerApp.latestImageTag é•œåƒå¤‡ä»½åˆ° dockerApp.imageName()
    this.execCommandByForce("docker image rm ${dockerApp.imageName()}")
    this.execCommand("docker tag ${dockerApp.latestImageTag} ${dockerApp.imageName()}")
  }

  def reloadMainService(DockerApp dockerApp, RuntimeParams params) {
    if (params.commandsHolder) {
      this.execCommandsInDockerByForce(dockerApp.containerName(), params.commandsHolder.onMainServiceWillStop)
    }
    this.execCommandByForce("docker container stop ${dockerApp.containerName()}")
    this.execCommandByForce("docker container rm ${dockerApp.containerName()}")
    def tagsParams = [
      Tags: ['Main']
    ]
    def envConfigData = JsonOutput.toJson(tagsParams + params.envConfigData)
    def envConfigDataExtras = JsonOutput.toJson(tagsParams + params.envConfigDataExtras + dockerApp.getConfigDataExtras())
    def hostnameSuffix = params.hostnameSuffix ? "-${params.hostnameSuffix}" : ''

    def portMapperList = dockerApp.makePortMapperList()
    // --restart=unless-stopped: è‡ªåŠ¨é‡å¯ï¼Œé™¤éæ”¶åˆ°æš‚åœè¿‡
    // --hostname=`hostname` ä½¿ç”¨å®¿ä¸» hostname
    // -v å°† logs ç›®å½• mount åˆ°å®¿ä¸»ï¼Œä¸ŠæŠ¥æ—¥å¿—
    this.execCommand("docker run -d --restart=unless-stopped \
        --hostname=\"${dockerApp.realName()}-`hostname`${hostnameSuffix}\" \
        --name=${dockerApp.containerName()} \
        --memory=\"${params.memoryLimit}\" \
        -v '${dockerApp.logsDir()}:${dockerApp.logsDir()}' \
        -e 'ENV=${params.configEnv}' \
        -e 'configSecret=${params.configSecret}' \
        -e 'NODE_CONFIG_EXTRA_JS=${params.extraConfigPath}' \
        -e 'ENV_CONFIG_DATA=${envConfigData}' \
        -e 'ENV_CONFIG_DATA_EXTRAS=${envConfigDataExtras}' \
        ${dockerApp.bindVolumesStr()} \
        ${portMapperList.collect({ "-p ${it.hostPort}:${it.containerPort}" }).join(' ')} \
        ${dockerApp.imageName()} \
    ")
    if (params.commandsHolder) {
      this.execCommandsInDocker(dockerApp.containerName(), params.commandsHolder.onMainServiceDidStart)
    }
  }

  def restoreBackupServiceFromBackup(DockerApp dockerApp, RuntimeParams params) {
    // åˆ é™¤å½“å‰ dockerApp.imageName() é•œåƒï¼Œå¹¶å°† dockerApp.imageNameBak() é•œåƒå¤‡ä»½åˆ° dockerApp.imageName()
    this.execCommandByForce("docker image rm ${dockerApp.imageName()}")
    this.execCommand("docker tag ${dockerApp.imageNameBak()} ${dockerApp.imageName()}")
    // é‡æ–°å¯åŠ¨ä¸»æœåŠ¡
    this.reloadMainService(dockerApp, params)
  }

  def execCommandsInDockerByForce(String containerName, String[] commands) {
    this.execCommandsInDocker(containerName, commands, true)
  }

  def execCommandsInDocker(String containerName, String[] commands, Boolean ignoreError = false) {
    for (String cmd in commands) {
      def safeCmd = cmd.replace('"', '\\"')
      this.execCommand("docker exec -t ${containerName} sh -c \"${safeCmd}\"", ignoreError)
    }
  }

  def dropBackupService(DockerApp dockerApp) {
    // ç»ˆæ­¢å½“å‰è¿è¡Œçš„ dockerApp.containerNameBak() å®¹å™¨
    this.execCommandByForce("docker container stop ${dockerApp.containerNameBak()}")
    this.execCommandByForce("docker container rm ${dockerApp.containerNameBak()}")
  }

  def notify(String message) {
    MessagePusher.notify("[Jenkins - ${this.name}] ${message}")
  }
}

RemoteHost.jenkins = this

class CurlParams {
  String url
  String method = 'GET'
  Object bodyData = null
  Boolean ignoreError = false

  def build() {
    def command = "curl --silent --fail --show-error --connect-timeout 3 -X ${this.method} \"${this.url}\""
    if (this.bodyData) {
      command = "${command} -H \"Content-type: application/json\" --data '${JsonOutput.toJson(this.bodyData)}'"
    }
    if (this.ignoreError) {
      command = "${command} || true"
    }
    return command
  }
}

class DockerCommandsHolder {
  public String[] onMainServiceWillStop = []
  public String[] onMainServiceDidStart = []
}

class RuntimeParams {
  public String configEnv
  public String extraConfigPath = ''
  public String hostnameSuffix = ''
  public String configSecret = ''
  public envConfigData = []
  public envConfigDataExtras = []
  public DockerCommandsHolder commandsHolder = null
  public String memoryLimit = '1024m'
}

class RuntimeExtrasParams {
  public String extraConfigPath = null
  public Object envConfigDataExtras = null
  public DockerCommandsHolder commandsHolder = null
  public String memoryLimit = null
}

class PortMapper {
  public Integer hostPort
  public Integer hostPortBak
  public Integer containerPort
}

class DockerApp {
  public String appName
  public String dockerfilePath
  public String dockerImageRepo

  public String latestImageTag
  public String[] bindVolumes = []
  public PortMapper[] portMapperList

  // ç”¨äºé‡å¯åº”ç”¨çš„å‘½ä»¤è¡Œ
  public String commandForReloading = 'pm2 reload all'

  // è‹¥ healthApiPath è¢«å®šä¹‰ï¼ŒDocker å®¹å™¨å¯åŠ¨æ—¶ï¼Œä¼šæ ¹æ®å®šä¹‰å¯¹å®¹å™¨è¿›è¡Œå¥åº·æ£€æŸ¥
  public String healthApiPath
  // è‹¥ retainHealthWord è¢«å®šä¹‰ï¼Œåˆ™ä¼šè¦æ±‚ healthApiPath çš„å“åº”å†…å®¹ä¸ retainHealthWord åŒ¹é…
  public String retainHealthWord

  // ä¸€èˆ¬æƒ…å†µä¸‹ä»…ç”¨äº staging ä¸»æœåŠ¡
  public CustomDockerParams customDockerParams

  public PortMapper[] makePortMapperList() {
    if (this.customDockerParams && this.customDockerParams.portMapperList) {
      return this.customDockerParams.portMapperList
    }
    assert this.portMapperList != null
    return this.portMapperList
  }

  public Integer[] ports() {
    def portMapperList = this.makePortMapperList()
    return (Integer[]) (portMapperList.collect({ it.hostPort }))
  }

  public Integer[] portsBak() {
    def portMapperList = this.makePortMapperList()
    return (Integer[]) (portMapperList.collect({ it.hostPortBak }))
  }

  def setCustomDockerParams(CustomDockerParams params) {
    this.customDockerParams = params
  }

  def getConfigDataExtras() {
    if (this.customDockerParams) {
      return this.customDockerParams.configDataExtras
    }
    return []
  }

  def realName() {
    if (this.customDockerParams) {
      return "${this.appName}.${this.customDockerParams.suffix}"
    }
    return this.appName
  }

  def logsDir() {
    return "/data/logs/${this.appName}"
  }

  def bindVolumesStr() {
    return this.bindVolumes.collect({ "-v '${it}:${it}'" }).join(' ')
  }

  def containerName() {
    return "container.${this.realName()}"
  }

  def containerNameBak() {
    return "container.${this.realName()}.bak"
  }

  def imageName() {
    return "${this.realName()}"
  }

  def imageNameBak() {
    return "${this.realName()}.bak"
  }
}

class KongService {
  public String region;
  public RemoteHost kongHost;
  public String upstreamName;
  public String healthApiPath;
  public String[] targetHosts;
  public String targetMainPort;
  public String targetBackupPort;
  public customWeightMap = []
}

class ConfigSource {
  public String gitUrl
  public String credentialsId
  public String tagName
  public String appName
}

class CustomDockerParams {
  public String suffix
  /**
   * @deprecated
   */
  public Integer[] hostPorts
  public configDataExtras = []

  public PortMapper[] portMapperList
}

class JenkinsApp {
  static def jenkins

  // é…ç½®æ–‡ä»¶å¯†ç 
  public String configSecret = ''

  //  Staging æœåŠ¡å™¨
  public RemoteHost stagingHost;

  //  Preview æœåŠ¡å™¨
  public RemoteHost previewHost;

  //  Production æœåŠ¡å™¨åˆ—è¡¨ï¼Œé»˜è®¤ä¸ºç©ºåˆ—è¡¨
  public RemoteHost[] productionHosts = []

  // ç½‘å…³åˆ—è¡¨ï¼Œåªä½œç”¨äºç”Ÿäº§ç¯å¢ƒï¼›ç”¨äºæ§åˆ¶åº”ç”¨æœåŠ¡ä¸Šä¸‹çº¿ï¼Œé»˜è®¤ä¸ºç©ºåˆ—è¡¨
  public KongService[] kongServices = []

  // æ˜¯å¦è·³è¿‡ä¸Šçº¿å‰çš„å¥åº·æ£€æŸ¥ï¼Œé»˜è®¤ä¸º false
  // ä¸€èˆ¬æ¥è¯´ï¼Œåªæœ‰åœ¨ç«¯å£ä¿¡æ¯å‘ç”Ÿå˜æ›´æ—¶æ‰ä¼šè·³è¿‡ä¸Šçº¿å‰å¥åº·æ£€æŸ¥
  public Boolean skipHealthCheck = false

  // åœ¨æœåŠ¡å¯åŠ¨åã€ç½‘å…³ä¸Šçº¿å‰éœ€è¦äººå·¥ç¡®è®¤ï¼Œé»˜è®¤ä¸º false
  public Boolean checkBeforeOnline = false

  // å‘å¸ƒæˆåŠŸååˆ é™¤å¤‡ç”¨æœåŠ¡
  public Boolean dropBackupServiceAfterSuccess = false

  // Docker é•œåƒè‹¥å·²å­˜åœ¨ï¼Œåˆ™ç›´æ¥è·³è¿‡é•œåƒå‡†å¤‡
  public Boolean lazyBuilding = true

  // Docker é•œåƒä¿¡æ¯å®šä¹‰ï¼Œæµ‹è¯•ç¯å¢ƒå’Œç”Ÿäº§ç¯å¢ƒé‡‡ç”¨åŒä¸€ä»½é•œåƒ
  public DockerApp dockerApp

  // Docker è¿è¡Œæ—¶çš„ä¸ªæ€§åŒ–é…ç½® (staging)
  public RuntimeParams stagingRetainParams

  // Docker è¿è¡Œæ—¶çš„ä¸ªæ€§åŒ–é…ç½® (preview)
  public RuntimeParams previewRetainParams

  // Docker è¿è¡Œæ—¶çš„ä¸ªæ€§åŒ–é…ç½® (production)ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¤šä¸ª production æœºå™¨é‡‡ç”¨ç›¸åŒçš„é…ç½®ä¿¡æ¯
  public RuntimeParams productionRetainParams

  // { remoteHost.name -> RuntimeExtrasParams } å­—å…¸ï¼Œä¸ºç”Ÿäº§ç¯å¢ƒç›®æ ‡æœºå™¨æä¾›ä¸ªæ€§åŒ–è¿è¡Œæ—¶é…ç½®
  public Map<String, RuntimeExtrasParams> remoteHostRuntimeExtrasParamsMap = new HashMap<>()

  // { remoteHost.name -> RuntimeParams } å­—å…¸ï¼Œå®é™…ä¸ºç”Ÿäº§ç¯å¢ƒæä¾›çš„é…ç½®ä¿¡æ¯ï¼Œå†…å®¹ä¸º productionRetainParams + envConfigData
  private Map<String, RuntimeParams> _remoteHostRuntimeParamsMap = new HashMap<>()

  // å¿«é€Ÿæ¨¡å¼ä¸‹ï¼Œä»…ä½œæ–°é•œåƒå‘å¸ƒåŠé‡æ–°å¯åŠ¨ï¼Œä¸ä¼šå¤åˆ¶å¤‡ç”¨æœåŠ¡ï¼Œä¸ä¼šå»å¤„ç†ç½‘å…³é…ç½®ï¼Œå‘å¸ƒæœŸé—´å¯èƒ½ä¼šå‡ºç°æœåŠ¡ä¸å¯ç”¨çš„æƒ…å†µ
  public Boolean quickMode = false

  // é…ç½®æ–‡ä»¶ä¿¡æ¯
  public ConfigSource configSource

  // Git Commit SHA
  private String commitSHA

  // å¯åŠ¨åº”ç”¨åˆ°å‡†å¤‡å®Œæ¯•çš„æ—¶é—´ï¼Œç”¨äºå¯åŠ¨åº”ç”¨åˆ°å¥åº·æ£€æŸ¥é—´çš„ä¼‘çœ å‚è€ƒï¼Œå•ä½: ç§’
  public Integer warmingTime = 3

  // é…ç½®æ–‡ä»¶ç›®å½•
  public String configDir = './config/'

  // å‘å¸ƒå‰å®¡è®¡å‘˜åˆ—è¡¨ï¼Œåˆ—è¡¨å†…çš„ç”¨æˆ·æ‰èƒ½æ‰§è¡Œå‘å¸ƒç¡®è®¤æ“ä½œï¼›åˆ—è¡¨ä¸ºç©ºï¼Œè¡¨ç¤ºæ‰€æœ‰ç”¨æˆ·å‡å¯æ‰§è¡Œå‘å¸ƒç¡®è®¤æ“ä½œ
  public String[] auditors = []

  // ç”¨äº staging ç¯å¢ƒçš„è‡ªå®šä¹‰ Docker å®¹å™¨
  private Map<String, CustomDockerParams> stagingCustomDockerParamsMap = new HashMap<>()

  // prepare å¿…é¡»è¢«è°ƒç”¨
  def prepare(String commitSHA, String gitBranch) {
    this.setCommitSHA(commitSHA)
    def params = this.extractStagingCustomDockerParams(gitBranch)
    if (params) {
      this.dockerApp.setCustomDockerParams(params)
    }
    def message = jenkins.sh(script: "git log -1", returnStdout: true)
    this.notify("å‡†å¤‡å‘å¸ƒ ${this.dockerApp.realName()}\n\n${message}", true)
  }

  // prepare å¿…é¡»è¢«è°ƒç”¨
  def setCommitSHA(String commitSHA) {
    assert this.dockerApp != null
    this.commitSHA = commitSHA
    this.dockerApp.latestImageTag = "${this.dockerApp.dockerImageRepo}:${commitSHA}"
  }

  def extractStagingCustomDockerParams(String gitBranch) {
    Pattern pattern = Pattern.compile("custom/${this.dockerApp.appName}/(\\w+)");
    Matcher matcher = pattern.matcher(gitBranch)
    if (matcher.find()) {
      String suffix = matcher.group(1)
      assert this.stagingCustomDockerParamsMap.containsKey(suffix)
      return this.stagingCustomDockerParamsMap[suffix]
    }
    return null
  }

  def notify(String message, withURL = false, String[] userEmailList = []) {
    if (withURL) {
      message = "${jenkins.BUILD_URL}console\n---\n${message}"
    }
    if (userEmailList.size() > 0) {
      message = "${message}\n\n"
    }
    MessagePusher.notify("[Jenkins - ${this.dockerApp.realName()}] ${message}")
  }

  def sendEmail(String title, String content, String[] receiverList) {
  }

  def runtimeParamsForRemoteHost(RemoteHost remoteHost, RuntimeParams retainParams) {
    def params = new RuntimeParams(
      configSecret: this.configSecret,
      configEnv: retainParams.configEnv,
      extraConfigPath: retainParams.extraConfigPath,
      envConfigData: retainParams.envConfigData,
      envConfigDataExtras: retainParams.envConfigDataExtras,
      commandsHolder: retainParams.commandsHolder,
      memoryLimit: retainParams.memoryLimit,
    )
    if (this.remoteHostRuntimeExtrasParamsMap[remoteHost.name]) {
      RuntimeExtrasParams runtimeExtrasParams = this.remoteHostRuntimeExtrasParamsMap[remoteHost.name]
      if (runtimeExtrasParams.extraConfigPath) {
        params.extraConfigPath = runtimeExtrasParams.extraConfigPath
      }
      if (runtimeExtrasParams.envConfigDataExtras) {
        params.envConfigDataExtras = runtimeExtrasParams.envConfigDataExtras
      }
      if (runtimeExtrasParams.commandsHolder) {
        params.commandsHolder = runtimeExtrasParams.commandsHolder
      }
      if (runtimeExtrasParams.memoryLimit) {
        params.memoryLimit = runtimeExtrasParams.memoryLimit
      }
    }
    return params
  }

  def publishForStaging() {
    def dockerApp = this.dockerApp
    def remoteHost = this.stagingHost
    def params = this.runtimeParamsForRemoteHost(remoteHost, this.stagingRetainParams)
    remoteHost.prepareMainDockerImage(dockerApp)
    remoteHost.reloadMainService(dockerApp, params)
  }

  def publishForPreview() {
    def dockerApp = this.dockerApp
    def remoteHost = this.previewHost
    def params = this.runtimeParamsForRemoteHost(remoteHost, this.previewRetainParams)
    remoteHost.prepareMainDockerImage(dockerApp)
    remoteHost.reloadMainService(dockerApp, params)
  }

  def publishForCustomRemoteHost(RemoteHost remoteHost, RuntimeParams params) {
    params.configSecret = this.configSecret
    def dockerApp = this.dockerApp
    remoteHost.prepareMainDockerImage(dockerApp)
    remoteHost.reloadMainService(dockerApp, params)
  }

  def makeProductionRuntimeParams() {
    for (RemoteHost remoteHost in this.productionHosts) {
      def params = this.runtimeParamsForRemoteHost(remoteHost, this.productionRetainParams)
      this._remoteHostRuntimeParamsMap.put(remoteHost.name, params)
    }
  }

  def fetchLatestImagesForProduction() {
    def dockerApp = this.dockerApp
    for (RemoteHost remoteHost in this.productionHosts) {
      remoteHost.fetchLatestImage(dockerApp)
    }
  }

  def assertDockerAppHealthy(RemoteHost remoteHost, DockerApp dockerApp, Integer[] ports) {
    if (!this.skipHealthCheck && dockerApp.healthApiPath) {
      jenkins.sleep(time: this.warmingTime, unit: 'SECONDS')
      for (Integer port in ports) {
        def response = remoteHost.execCurl(new CurlParams(
          method: 'GET',
          url: "http://127.0.0.1:${port}${dockerApp.healthApiPath}"
        ))
        if (dockerApp.retainHealthWord) {
          assert response == dockerApp.retainHealthWord
        }
      }
    }
  }

  def publishForBackup() {
    this.fetchLatestImagesForProduction()

    def dockerApp = this.dockerApp
    this.notify('âœ”ï¸ æœåŠ¡å³å°†å‘å¸ƒåˆ°ç”Ÿäº§ç¯å¢ƒ - Backup')

    this.makeProductionRuntimeParams()
    for (RemoteHost remoteHost in this.productionHosts) {
      def params = this._remoteHostRuntimeParamsMap[remoteHost.name] as RuntimeParams
      remoteHost.publishLatestToBackupService(dockerApp, params)
      this.assertDockerAppHealthy(remoteHost, dockerApp, dockerApp.portsBak())
    }
    this.notify('âœ”ï¸ å¤‡ç”¨æœåŠ¡å·²æˆåŠŸå¯åŠ¨')
  }

  def publishForProduction() {
    this.fetchLatestImagesForProduction()
    this.waitingForAudit('è¯·ç¡®è®¤æ˜¯å¦å‘å¸ƒåˆ°ç”Ÿäº§ç¯å¢ƒ?')

    def dockerApp = this.dockerApp
    this.notify('âœ”ï¸ æœåŠ¡å³å°†å‘å¸ƒåˆ°ç”Ÿäº§ç¯å¢ƒ')

    this.makeProductionRuntimeParams()
    if (this.quickMode) {
      for (RemoteHost remoteHost in this.productionHosts) {
        def params = this._remoteHostRuntimeParamsMap[remoteHost.name] as RuntimeParams
        remoteHost.prepareMainDockerImage(dockerApp)
        remoteHost.reloadMainService(dockerApp, params)
        this.assertDockerAppHealthy(remoteHost, dockerApp, dockerApp.ports())
      }
      return
    }

    this.kong_checkTargetsStatus()
    this.notify('âœ”ï¸ ç½‘å…³çŠ¶æ€æ­£å¸¸ï¼Œå³å°†å‘å¸ƒ')

    for (RemoteHost remoteHost in this.productionHosts) {
      // é’ˆå¯¹æ–°å¢æœºå™¨ï¼šè‹¥ä¸»æœåŠ¡ä¸å­˜åœ¨ï¼Œåˆ™å…ˆå¯åŠ¨ä¸»æœåŠ¡ï¼Œä»¥ä¾¿å¤‡ç”¨æœåŠ¡å¤åˆ¶
      if (!remoteHost.checkMainDockerContainerExists(dockerApp)) {
        this.notify("âœ”ï¸ ${remoteHost.name} ä¸­ä¸å­˜åœ¨ä¸»æœåŠ¡ï¼Œå³å°†åˆ›å»ºå¹¶å¯åŠ¨...")
        def params = this._remoteHostRuntimeParamsMap[remoteHost.name] as RuntimeParams
        remoteHost.prepareMainDockerImage(dockerApp)
        remoteHost.reloadMainService(dockerApp, params)
        this.assertDockerAppHealthy(remoteHost, dockerApp, dockerApp.ports())
      }
    }

    for (RemoteHost remoteHost in this.productionHosts) {
      def params = this._remoteHostRuntimeParamsMap[remoteHost.name] as RuntimeParams
      remoteHost.duplicateBackupService(dockerApp, params)
      this.assertDockerAppHealthy(remoteHost, dockerApp, dockerApp.portsBak())
    }
    this.notify('âœ”ï¸ å¤‡ç”¨æœåŠ¡å¤åˆ¶å¹¶å¯åŠ¨')
    jenkins.sleep(time: this.warmingTime, unit: 'SECONDS')
    if (this.kongServices.size() > 0) {
      this.kong_publishBackupTargets()
      this.notify('âœ”ï¸ å¤‡ç”¨æœåŠ¡å·²ä¸Šçº¿')
      this.kong_dismissMainTargets()
      this.notify('âœ”ï¸ ä¸»æœåŠ¡å·²ä¸‹çº¿')
    }

    try {
      for (RemoteHost remoteHost in this.productionHosts) {
        def params = this._remoteHostRuntimeParamsMap[remoteHost.name] as RuntimeParams
        remoteHost.prepareMainDockerImage(dockerApp)
        remoteHost.reloadMainService(dockerApp, params)
        this.assertDockerAppHealthy(remoteHost, dockerApp, dockerApp.ports())
      }
    } catch (Exception e) {
      this.notify('âš ï¸ï¸ ä¸»æœåŠ¡éƒ¨ç½²å¤±è´¥ï¼Œå³å°†å›æ»š')
      for (RemoteHost remoteHost in this.productionHosts) {
        def params = this._remoteHostRuntimeParamsMap[remoteHost.name] as RuntimeParams
        remoteHost.restoreBackupServiceFromBackup(dockerApp, params)
        if (!this.skipHealthCheck && dockerApp.healthApiPath) {
          jenkins.sleep(time: this.warmingTime, unit: 'SECONDS')
          for (Integer port in dockerApp.ports()) {
            remoteHost.execCurl(new CurlParams(
              method: 'GET',
              url: "http://127.0.0.1:${port}${dockerApp.healthApiPath}"
            ))
          }
        }
      }
      this.kong_publishMainTargets()
      this.notify('âš ï¸ï¸ æ—§ç‰ˆä¸»æœåŠ¡å·²é‡æ–°ä¸Šçº¿')
      this.kong_dismissBackupTargets()
      this.notify('âš ï¸ï¸ï¸ å¤‡ç”¨æœåŠ¡å·²ä¸‹çº¿')
      this.notify('âœ”ï¸ å›æ»šå®Œæˆ')
      throw e
    }

    this.notify("âœ”ï¸ æ–°çš„é•œåƒå·²éƒ¨ç½²ï¼Œä¸»æœåŠ¡å·²é‡æ–°å¯åŠ¨ã€‚Git Commit: ${this.commitSHA}")

    if (this.kongServices.size() > 0) {
      jenkins.sleep(time: this.warmingTime, unit: 'SECONDS')
      if (this.checkBeforeOnline) {
        this.waitingForAudit('ä¸Šçº¿åæµé‡å°†æŒ‡å‘ä¸»æœåŠ¡ï¼Œç¡®è®¤ä¸Šçº¿å—?')
      }
      this.kong_publishMainTargets()
      this.notify('âœ”ï¸ ä¸»æœåŠ¡å·²ä¸Šçº¿')
      this.kong_dismissBackupTargets()
      this.notify('âœ”ï¸ å¤‡ç”¨æœåŠ¡å·²ä¸‹çº¿')
    }

    if (this.dropBackupServiceAfterSuccess) {
      jenkins.sleep(time: 5, unit: 'SECONDS')
      for (RemoteHost remoteHost in this.productionHosts) {
        remoteHost.dropBackupService(dockerApp)
      }
      this.notify('âœ”ï¸ å¤‡ç”¨æœåŠ¡å·²åœæ­¢è¿è¡Œ')
    }
  }

  /**
   * @description ç¡®ä¿å½“å‰ç½‘å…³ Target æŒ‡å‘ä¸ºä¸»æœåŠ¡ï¼Œæˆ– Target åˆ—è¡¨ä¸ºç©º
   */
  def kong_checkTargetsStatus() {
    for (KongService kongService in this.kongServices) {
      def kongHost = kongService.kongHost
      for (String targetHost in kongService.targetHosts) {
        def responseText = kongHost.execCurl(new CurlParams(
          method: 'GET',
          url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets"
        )) as String
        def responseObj = new JsonSlurper().parseText(responseText)
        def targetList = responseObj['data'] as List
        def hasMainTarget = false
        for (targetInfo in targetList) {
          def target = targetInfo['target'] as String
          if (target.endsWith(":${kongService.targetMainPort}")) {
            hasMainTarget = true
            break
          }
        }
        assert targetList.size() == 0 || hasMainTarget
      }
    }
  }

  def kong_publishBackupTargets() {
    try {
      for (KongService kongService in this.kongServices) {
        def kongHost = kongService.kongHost
        for (String targetHost in kongService.targetHosts) {
          def backupTarget = "${targetHost}:${kongService.targetBackupPort}"
          if (!this.skipHealthCheck) {
            kongHost.execCurl(new CurlParams(
              method: 'GET',
              url: "http://${backupTarget}${kongService.healthApiPath}"
            ))
          }
          kongHost.execCurl(new CurlParams(
            method: 'POST',
            url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets",
            bodyData: [
              target: backupTarget,
              weight: 1000,
              tags  : ['Backup']
            ]
          ))
        }
      }
    } catch (Exception e) {
      this.notify('âš ï¸ï¸ å¤‡ç”¨æœåŠ¡ä¸Šçº¿å¤±è´¥ï¼Œå°†æ¸…ç†å·²ä¸Šçº¿çš„å¤‡ç”¨æœåŠ¡')
      this.kong_dismissBackupTargets()
      this.notify('âš ï¸ï¸ï¸ å¤‡ç”¨æœåŠ¡å‡å·²ä¸‹çº¿')
      this.notify('âœ”ï¸ å›æ»šå®Œæˆ')
      throw e
    }
  }

  def kong_dismissBackupTargets() {
    for (KongService kongService in this.kongServices) {
      def kongHost = kongService.kongHost
      for (String targetHost in kongService.targetHosts) {
        def backupTarget = "${targetHost}:${kongService.targetBackupPort}"
        kongHost.execCurl(new CurlParams(
          method: 'DELETE',
          url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets/${backupTarget}",
          ignoreError: true
        ))
      }
    }
  }

  def kong_publishMainTargets() {
    for (KongService kongService in this.kongServices) {
      def kongHost = kongService.kongHost
      for (String targetHost in kongService.targetHosts) {
        def mainTarget = "${targetHost}:${kongService.targetMainPort}"
        if (!this.skipHealthCheck) {
          kongHost.execCurl(new CurlParams(
            method: 'GET',
            url: "http://${mainTarget}${kongService.healthApiPath}"
          ))
        }
        def customWeightMap = kongService.customWeightMap
        kongHost.execCurl(new CurlParams(
          method: 'POST',
          url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets",
          bodyData: [
            target: mainTarget,
            weight: customWeightMap[targetHost] ? customWeightMap[targetHost] : 1000,
            tags  : ['Main']
          ]
        ))
      }
    }
  }

  def kong_dismissMainTargets() {
    for (KongService kongService in this.kongServices) {
      def kongHost = kongService.kongHost
      for (String targetHost in kongService.targetHosts) {
        def mainTarget = "${targetHost}:${kongService.targetMainPort}"
        kongHost.execCurl(new CurlParams(
          method: 'DELETE',
          url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets/${mainTarget}",
          ignoreError: true
        ))
      }
    }
  }

  def copyConfigFiles() {
    if (!this.dockerApp) {
      return
    }
    jenkins.sh "mkdir -p ./deploy/build/my-config"
    jenkins.dir("./deploy/build/my-config") {
      // git: https://www.jenkins.io/doc/pipeline/steps/git/
      jenkins.checkout poll: false,
        scm: [
          $class           : 'GitSCM',
          userRemoteConfigs: [
            [
              url: this.configSource.gitUrl, credentialsId: this.configSource.credentialsId]
          ],
          branches         : [[name: "refs/tags/${this.configSource.tagName}"]]
        ]
    }
    jenkins.sh "cp ./deploy/build/my-config/apps/${this.configSource.appName}/* ${configDir}"
    // æš‚æ—¶å¿½ç•¥æ­¤æ­¥éª¤å¯èƒ½å‘ç”Ÿçš„é”™è¯¯
    jenkins.sh "cp ./deploy/build/my-config/core/ali-oss-lazy-upload/*.js ./deploy/docker.deps/ || true"
    jenkins.sh "cp ./deploy/build/my-config/core/ali-oss-download/*.js ./deploy/docker.deps/ || true"
    jenkins.sh "rm -rf ./deploy/build/my-config"
  }

  public Boolean checkDockerImageExists() {
    assert this.dockerApp != null
    assert this.commitSHA != null

    try {
      jenkins.sh "docker pull ${this.dockerApp.dockerImageRepo}:${this.commitSHA}"
      return true
    } catch (Exception e) {
    }
    return false
  }

  def prepareDockerImage() {
    assert this.dockerApp != null && this.dockerApp.latestImageTag != null
    assert this.commitSHA != null

    if (this.lazyBuilding) {
      if (this.checkDockerImageExists()) {
        this.notify("å½“å‰é•œåƒå·²å­˜åœ¨ï¼Œè·³è¿‡ Docker é•œåƒæ„å»ºæ“ä½œ")
        return
      }
    }
    def dockerApp = this.dockerApp
    def latestImageTag = this.dockerApp.latestImageTag
    jenkins.sh """
      docker build -t ${dockerApp.imageName()} -f ${dockerApp.dockerfilePath} . \
        --network=host \
        --build-arg commitSHA=${this.commitSHA} \
        --build-arg configSecret=${this.configSecret}
    """

    jenkins.sh "docker tag ${dockerApp.imageName()} ${latestImageTag}"
    jenkins.sh "docker push ${latestImageTag}"
  }

  def waitingForAudit(String hints) {
    def auditorsStr = this.auditors.size() > 0 ? this.auditors.join(', ') : 'ä»»ä½•äºº'
    def message = "${hints}\nå®¡æ‰¹äºº: ${auditorsStr}"
    this.notify(message, true, this.auditors)

    if (this.auditors.size() > 0) {
      this.sendEmail(
        "[å‘ç‰ˆç¡®è®¤] ${this.dockerApp.realName()}",
        "è¯·å‰å¾€ <a href=\"${jenkins.JOB_URL}\" target=\"_blank\">${jenkins.JOB_URL}</a> æŸ¥çœ‹å‘å¸ƒçŠ¶æ€å¹¶è¿›è¡Œå‘ç‰ˆå®¡æ‰¹",
        this.auditors
      )
    }
    /**
     * https://www.jenkins.io/doc/pipeline/steps/pipeline-input-step/#input-wait-for-interactive-input
     * æ–‡æ¡£ä¸­æåˆ°çš„ submitter ä¼¼ä¹æ²¡æœ‰èµ·åˆ°ä½œç”¨ï¼Œæ•…å¼ƒç”¨
     */
    def approved = false
    while (!approved) {
      def auditor = jenkins.input message: message, submitterParameter: 'submitter', ok: 'ç¡®å®š'
      if (this.auditors.size() == 0 || this.auditors.contains(auditor)) {
        approved = true
        this.notify("${auditor} é€šè¿‡äº†å‘å¸ƒå®¡æ‰¹")
      } else {
        jenkins.echo "${auditor} æ— æƒå®¡æ‰¹ï¼Œè¯·é€šçŸ¥ ${auditorsStr} è¿›è¡Œå®¡æ‰¹"
      }
    }
  }

  def reloadProductionApps() {
    assert this.dockerApp.commandForReloading != null
    this.waitingForAudit('è¯·ç¡®è®¤æ˜¯å¦é‡å¯?')

    this.notify("å‡†å¤‡é‡å¯ ${this.dockerApp.appName}", true)
    for (RemoteHost remoteHost in this.productionHosts) {
      def internalIPAddress = remoteHost.internalIPAddress

      for (KongService kongService in this.kongServices) {
        assert kongService.targetHosts.length > 1
        def kongHost = kongService.kongHost
        for (String targetHost in kongService.targetHosts) {
          def mainTarget = "${internalIPAddress}:${kongService.targetMainPort}"
          if (internalIPAddress.equals(targetHost)) {
            kongHost.execCurl(new CurlParams(
              method: 'DELETE',
              url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets/${mainTarget}",
              ignoreError: true
            ))
          }
        }
      }
      this.notify("âœ”ï¸ ${this.dockerApp.appName}@${remoteHost.name} å·²ä»ç½‘å…³ä¸‹çº¿")

      remoteHost.execCommandsInDocker(this.dockerApp.containerName(), (String[]) ([this.dockerApp.commandForReloading]), true)
      this.assertDockerAppHealthy(remoteHost, this.dockerApp, this.dockerApp.ports())
      this.notify("âœ”ï¸ ${this.dockerApp.appName}@${remoteHost.name} æœåŠ¡å·²é‡å¯")

      for (KongService kongService in this.kongServices) {
        def kongHost = kongService.kongHost
        for (String targetHost in kongService.targetHosts) {
          def mainTarget = "${internalIPAddress}:${kongService.targetMainPort}"
          if (internalIPAddress.equals(targetHost)) {
            if (!this.skipHealthCheck) {
              kongHost.execCurl(new CurlParams(
                method: 'GET',
                url: "http://${mainTarget}${kongService.healthApiPath}"
              ))
            }
            def customWeightMap = kongService.customWeightMap
            kongHost.execCurl(new CurlParams(
              method: 'POST',
              url: "http://127.0.0.1:8001/upstreams/${kongService.upstreamName}/targets",
              bodyData: [
                target: mainTarget,
                weight: customWeightMap[targetHost] ? customWeightMap[targetHost] : 1000,
                tags  : ['Main']
              ]
            ))
          }
        }
      }
      this.notify("âœ”ï¸ ${this.dockerApp.appName}@${remoteHost.name} å·²ä¸Šçº¿")
    }
  }
}

JenkinsApp.jenkins = this
////////////////////// å…¬å…±ä»£ç  END //////////////////////

def myApp = new JenkinsApp(
  dropBackupServiceAfterSuccess: true,
  // quickMode = true æ—¶ï¼Œä»…ä½œæ–°é•œåƒå‘å¸ƒåŠé‡æ–°å¯åŠ¨ï¼Œä¸ä¼šå¤åˆ¶å¤‡ç”¨æœåŠ¡ï¼Œä¸ä¼šå»å¤„ç†ç½‘å…³é…ç½®ï¼Œå‘å¸ƒæœŸé—´å¯èƒ½ä¼šå‡ºç°æœåŠ¡ä¸å¯ç”¨çš„æƒ…å†µ (reload æœåŠ¡çš„çŸ­æš‚æ—¶é—´)
//  quickMode: true,
  auditors: [],
  dockerApp: new DockerApp(
    appName: 'tmpl-demo',
    dockerfilePath: './deploy/tmpl-demo/Dockerfile',
    dockerImageRepo: 'hub.your_host.app/project/tmpl-demo',
    portMapperList: [
      new PortMapper(hostPort: 2300, hostPortBak: 12300, containerPort: 2300),
      new PortMapper(hostPort: 2399, hostPortBak: 12399, containerPort: 2399),
    ],
    healthApiPath: '/api/health/ping',
  ),
  stagingRetainParams: new RuntimeParams(
    configEnv: 'staging',
  ),
  previewRetainParams: new RuntimeParams(
    configEnv: 'production',
  ),
  productionRetainParams: new RuntimeParams(
    configEnv: 'production',
  ),
  stagingHost: new RemoteHost(name: 'sh-staging', host: 'xxx.xxx.xxx.xxx', internalIPAddress: 'yyy.yyy.yyy.yyy', port: 22, user: 'ubuntu'),
  productionHosts: [
    new RemoteHost(name: 'app-sh-xxx.xxx.xxx.xxx-yyy.yyy.yyy.yyy', host: 'xxx.xxx.xxx.xxx', internalIPAddress: 'yyy.yyy.yyy.yyy', port: 22, user: 'ubuntu'),
  ],
  kongServices: [
    new KongService(
      region: 'kong-sh',
      kongHost: new RemoteHost(name: 'ap-sh-xxx', host: 'xxx.xxx.xxx.xxx', port: 22, user: 'ubuntu'),
      upstreamName: 'upstream.prod.tmpl-demo-admin',
      healthApiPath: '/api/health/ping',
      targetHosts: [
        '10.0.0.1',
        '10.0.0.2',
      ],
      targetMainPort: 2399,
      targetBackupPort: 12399,
    ),
  ]
)

pipeline {
  agent any
  // https://www.jenkins.io/doc/book/pipeline/syntax/#options
  options {
    disableConcurrentBuilds()
  }
  environment {
    // GIT_COMMIT: https://plugins.jenkins.io/git/
    COMMIT = GIT_COMMIT.substring(0, 8)
    BRANCH_NAME = "${GIT_BRANCH}"
    // credentials: https://www.jenkins.io/doc/book/using/using-credentials/
    DEPLOY_ACCESS_KEY = credentials('SSHKeyStr_Jenkins')
    HUB_USERNAME = credentials('Harbor_Username')
    HUB_PASSWORD = credentials('Harbor_Password')
    HUB_LOGIN = "docker login hub.your_host.app -u \"${HUB_USERNAME}\" -p \"${HUB_PASSWORD}\""
  }
  stages {
    stage('å‘å¸ƒåº”ç”¨åˆå§‹åŒ–') {
      steps {
        script {
          myApp.prepare("${COMMIT}", "${BRANCH_NAME}")
          sh "${HUB_LOGIN}"
        }
      }
    }
    stage('å‡†å¤‡ Docker é•œåƒ') {
      steps {
        script {
          myApp.prepareDockerImage()
        }
      }
    }
    stage('Deploy - Staging') {
      when {
        branch 'staging/tmpl-demo'
      }
      steps {
        script {
          myApp.publishForStaging()
        }
      }
    }
    stage('Deploy - Production') {
      when {
        branch 'release/tmpl-demo'
      }
      steps {
        script {
          myApp.publishForProduction()
        }
      }
    }
  }
  post {
    success {
      script {
        myApp.notify('ğŸš€ å‘å¸ƒæˆåŠŸ', true)
      }
    }
    failure {
      script {
        myApp.notify('âŒ å‘å¸ƒå¤±è´¥', true)
      }
    }
    aborted {
      script {
        myApp.notify('ğŸš« å‘å¸ƒè¢«ç»ˆæ­¢', true)
      }
    }
  }
}
